# 리액트

  - SPA(Single Page Application)를 효율적으로 만들기 위해 사용하는 라이브러리
  - 자바스크립트를 활용하여 한 페이지에서 하나의 어플리케이션처럼 동작하도록 
    모든것을 만들어버리는 방식을 SPA라고 한다
  - 기본 자바스크립트만으로도 충분히 SPA를 구현할 수 있지만
    코드가 너무 길어지므로 다른 라이브러리의 필요성이 생기게 되었다
  - 비슷한 역할을 하는 라이브러리들로는 Vue.js, Svelte등이 있지만
    가장 오래되고 사용자가 많은 라이브러리는 React이다

# 리액트 설치 및 프로젝트 생성
  
  1. Node.js 설치
  2. Visual Studio Code에서 터미널 오픈 후 npm create vite@latest
     (보안 오류나면 Powershell 관리자 권한으로 틀어서 Set-ExecutionPolicy RemoteSigned로 설정하고 다시 해야함)
  3. 생성 후 해당 프로젝트 경로에 들어가서 npm install
  4. 해당 프로젝트 경로에서 npm run dev로 프로젝트 실행

# 리액트의 메인 컨셉들

  - 컴포넌트 단위로 html 재사용
  - 함수형 컴포넌트 (최신식)
  - 클래스형 컴포넌트 (구식)
  - 렌더링
  - state
  - props
  - hooks (함수형 컴포넌트)

# 리액트 프로젝트 구조

  - node-modules : npm install을 실행하면 필요한 라이브러리들을 설치하는 장소
  - package.json : 이 프로젝트에 필요한 라이브러리들을 기록하기 위한 파일
  - public 폴더 : 정적 자원 보관소
  - index.html : 메인페이지 
    (App.jsx 내용을 main.jsx에 넣고 그걸 index.html에 넣는 식으로 만들어져 있음)

# JSX

  - return의 ()내부 영역을 JSX 영역이라고 한다
  - JSX에서는 요소의 class를 정의할 때 className을 써야한다 (자바스크립트의 class 문법과 겹침)
  - 중괄호를 사용하면 JSX 문법을 탈출하여 자바스크립트를 사용할 수 있다 (모든 문법을 쓸 수 있는 것은 아님)
  - 요소에 style을 넣을 땐 자바스크립트 객체를 사용해야 한다
  - 기본적으로 App.css의 스타일이 적용되고 있다
  - return ()안에는 병렬로 태그를 2개 이상 사용할 수 없다 (하나의 함수가 하나의 컴포넌트만을 의미해야 한다)
    (병렬로 반드시 구성하고 싶다면 비어있는 태그를 사용해 묶을 수는 있다)
  - 이벤트 핸들러 속성(ex: onclick)은 onClick처럼 camelCase로 사용해야 한다

# state

  - 값이 변했을 때 화면에 반영되어야 하는 변수는 state로 만들어서 사용해야 한다
  - 리액트는 state의 변화가 감지되면 화면을 다시 그리는(재랜더링) 하는 방식으로 만들어져 있다
  - 배열 또는 객체의 값(알맹이)만 변경된 경우 변화가 감지되지 않아 화면을 다시 그리지 않는 문제가 발생할 수 있다
  - 값이 변했을 때 화면에 반영되지 않아도 되는 변수는 그냥 변수를 사용해야 한다
  - state를 너무 남발하면 화면을 계속 새로고침하기 때문에 성능이 저하될 우려가 있다
  - state는 react의 useState() 메서드를 사용해 인스턴스를 주입받아 사용한다 (hooks)
  - state는 반드시 해당 state를 생성할 때 받아온 setter를 사용해 변화시켜야 한다

# 이벤트 핸들러

  - onClick={() => {}}
  - onClick={function() {}}
  - onClick={ onclickHandler }
  - 리액트는 이벤트에서 setter를 통해 state만 변화시켜서 화면을 갱신하는 방식을 많이 사용한다

# 컴포넌트

  - 함수형 컴포넌트
  - 함수를 선언하고 return () 안에 JSX문법으로 반환하면 컴포넌트가 된다
  - 가져다 쓸 때는 <함수명 />로 사용하면 된다
  - 화살표 함수로 만드는 것도 가능하다
  - 클래스형 컴포넌트

# 조건문

  - 리액트의 JSX의 {}에서는 if문을 사용할 수 없기 때문에 삼항 연산자를 대신 사용해야 한다
  - 화면에 아무것도 안그리고 싶을 때는 null을 사용하면 된다

# 반복문

  - JSX의 {}에서는 for문을 사용할 수 없기 때문에 주로 배열의 map을 활용한다
  - map의 결과로 원하는 컴포넌트들이 들어있는 배열이 생성되면 리액트가 그것을 화면에 추가한다
  - 반복문으로 컴포넌트를 생성할 때는 각 컴포넌트에 key={고유값}을 추가해야 리액트 성능 향상에 도움된다

# props

  - 부모 컴포넌트에서 사용하던 state를 자식 컴포넌트로 전달하고 싶을 때 사용한다
  - html에서 일반적인 속성(attrivute) 추가하듯이 자식 컴포넌트에 추가해 전달한다
  - 자식 컴포넌트에서는 매개변수에 props 등록 후 props.속성이름으로 사용한다
  - 부모에서 자식으로만 전달 가능하고 자식에서 부모 또는 형제로 전송은 불가능하다
  - 컴포넌트가 많아질수록 props도 많아지기 때문에 컴포넌트를 너무 남발하지 않도록 주의해야 한다

# import, export

  - export : 현재 파일의 자원앞에 붙이면 다른 파일에서 가져다 쓸 수 있는 자원이 된다
  - export default : 자원 앞에 붙이면 이 파일을 대표하는 자원이 된다. 파일 맨 밑에 정의하기도 한다
                     ({} 없이 호출 할 때 불려지는 자원이 된다)
  - import {module...} from 'path' : 해당 파일 내부에 export가 붙은 자원을 가져다 쓰는 분법
                                     (모듈명 뒤에 as를 붙여 별칭을 지어 사용할 수 있다)
  - import module from 'path' : 해당 파일 내부에 export default가 붙은 자원을 가져다 쓰는 문법
                                (대표 모듈은 as 없이도 이름을 마음대로 변경해서 사용할 수 있다)

# 클래스 방식 컴포넌트

  1. 생성자에서 props를 받는다
  2. 생성자에서 state객체를 정의한다 (useState() 훅을 사용하지 않음, 개별 setter가 없음)
  3. render() 메서드를 정의해두면 렌더링시 호출된다
  4. componenetDidMount, componentDidUpdate, componentWillUnmount등으로
     특정 시점에 필요한 코드를 정의할 수 있다